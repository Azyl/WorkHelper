-- Create the user 
create user CRISOFTADMIN
identified by "manu123"
  default tablespace USERS
  temporary tablespace TEMP
  password expire;
-- Grant/Revoke object privileges 
grant select on SYS.DBA_DATA_FILES to CRISOFTADMIN;
grant select on SYS.DBA_FREE_SPACE to CRISOFTADMIN;
grant select on SYS.DBA_JOBS to CRISOFTADMIN;
grant select on SYS.DBA_OBJECTS to CRISOFTADMIN;
grant select on SYS.DBA_SEGMENTS to CRISOFTADMIN;
grant execute on SYS.UTL_SMTP to CRISOFTADMIN;
grant select on SYS.V_$BACKUP_PIECE to CRISOFTADMIN;
grant select on SYS.V_$BACKUP_SET to CRISOFTADMIN;
grant select on SYS.V_$INSTANCE to CRISOFTADMIN;
grant select on SYS.V_$LOCK to CRISOFTADMIN;
grant select on SYS.V_$PARAMETER to CRISOFTADMIN;
grant select on SYS.V_$RESOURCE_LIMIT to CRISOFTADMIN;
grant select on SYS.V_$RMAN_BACKUP_JOB_DETAILS to CRISOFTADMIN;
grant select on SYS.V_$SESSION to CRISOFTADMIN;
grant select on SYS.V_$SESSTAT to CRISOFTADMIN;
grant select on SYS.V_$SORT_USAGE to CRISOFTADMIN;
grant select on SYS.V_$STATNAME to CRISOFTADMIN;
-- Grant/Revoke role privileges 
grant connect to CRISOFTADMIN;
-- Grant/Revoke system privileges 
grant create database link to CRISOFTADMIN;
grant create procedure to CRISOFTADMIN;
grant create table to CRISOFTADMIN;

--------------------------------------------------------------------


create table email (    createdate date,
            maildate date,
            maildata clob,
            sent number(1),
            hostname varchar2(200)
            );

create database link LEMETTEST connect to CrisoftAdmin identified by manu123 using 'LEMETTEST.CRISOFT.RO';

---------------------------------------------------------------------
CREATE OR REPLACE PACKAGE Crisoftadmin.Crisoftadm AS
  TYPE ARRAY IS TABLE OF VARCHAR2(255);
  PROCEDURE Health_Check(Disk_Usage_Table VARCHAR2, Host_Name VARCHAR2);
  PROCEDURE Disk_Usage(Disk_Usage_Table VARCHAR2, Host_Name VARCHAR2);
  FUNCTION Printstyle RETURN VARCHAR2;
  FUNCTION Resources(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Tablespaces(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Dbdatafiles(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Invalidobjects(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Deadlocks(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Unextendableobjects(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Top10cpuusage(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Top10longoperations(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Top10idlesesions(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Temporarytablespaces(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Statisticsjobrun(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Backuprman(Tablenr NUMBER) RETURN VARCHAR2;
  FUNCTION Backuprmandetails(Tablenr NUMBER) RETURN VARCHAR2;
  PROCEDURE Html_Email(p_To            IN VARCHAR2,
                       p_From          IN VARCHAR2,
                       p_Subject       IN VARCHAR2,
                       p_Text          IN VARCHAR2,
                       p_Html          IN VARCHAR2,
                       p_Smtp_Hostname IN VARCHAR2,
                       p_Smtp_Portnum  IN VARCHAR2);

  PROCEDURE Html_Email_V2(p_To            IN ARRAY DEFAULT ARRAY(),
                          p_Cc            IN ARRAY DEFAULT ARRAY(),
                          p_Bcc           IN ARRAY DEFAULT ARRAY(),
                          p_From          IN VARCHAR2,
                          p_Subject       IN VARCHAR2,
                          p_Text          IN VARCHAR2,
                          p_Html          IN VARCHAR2,
                          p_Smtp_Hostname IN VARCHAR2,
                          p_Smtp_Portnum  IN VARCHAR2);

  FUNCTION Cssreset RETURN VARCHAR2;
  --PROCEDURE Email_Send(p_Job_Id NUMBER);

  --FUNCTION createTableHTML (t_id NUMBER) RETURN VARCHAR2;

  FUNCTION Address_Email(p_String IN VARCHAR2, p_Recipients IN ARRAY, l_Connection Utl_Smtp.Connection) RETURN VARCHAR2;

END Crisoftadm;



CREATE OR REPLACE PACKAGE BODY Crisoftadmin.Crisoftadm AS

  PROCEDURE Health_Check(Disk_Usage_Table VARCHAR2, Host_Name VARCHAR2) AS
    Resource_Limit VARCHAR2(2000);
    Cnt            INTEGER;
    Html_Body      CLOB;
    Recipient      VARCHAR2(200);
    Frrom          VARCHAR2(200);
    Subject        VARCHAR2(4000);
    Maxemailid     NUMBER;
    Instancename   VARCHAR2(4000);
    Hostname       VARCHAR2(4000);
    Smtphostname   VARCHAR2(200);
    Smtpportnumber VARCHAR2(6);
  BEGIN
    SELECT Instance_Name, Host_Name INTO Instancename, Hostname FROM V$instance;
    --SELECT MAX(Job_Id) + 1 INTO Maxemailid FROM Email_Message;
    Smtphostname   := 'localhost';
    Smtpportnumber := '465';
    Recipient      := 'andrei.tataru@mdlz.com';
    Frrom          := 'Crisoft_Admins@crisoft.ro';
    --frrom := 'andrei.tataru@crisoft.ro';
    Subject := 'Health Check on ' || Instancename || ' ' || Hostname || ' at ' || To_Char(SYSDATE);
    Dbms_Output.Put_Line(Subject);
    Html_Body := '<!DOCTYPE html>
<html>
<head>
';
    Html_Body := Html_Body || Printstyle || '
</head>

<body>';
    /* Html_Body := Html_Body || '<h1>' || Subject || '</h1>' || '<br><br><br>' || Resources(Tablenr => 1) ||
    '<br><br><br>' || Tablespaces(Tablenr => 2) || '<br><br><br>' || Dbdatafiles(Tablenr => 3) ||
    '<br><br><br>' || Invalidobjects(Tablenr => 4) || '<br><br><br>' || Deadlocks(Tablenr => 5) ||
    '<br><br><br>' || Unextendableobjects(Tablenr => 6) || '<br><br><br>' || Top10cpuusage(Tablenr => 7) ||
    '<br><br><br>' || Top10longoperations(Tablenr => 8) || '<br><br><br>' ||
    Temporarytablespaces(Tablenr => 9) || '<br><br><br>' || Top10idlesesions(Tablenr => 10) ||
    '<br><br><br>' || Statisticsjobrun(Tablenr => 11) || '<br><br><br>' || Backuprman(Tablenr => 12) ||
    '<br><br><br>' || Backuprmandetails(Tablenr => 13) || Disk_Usage_Table || '</body></html>';*/
  
    Html_Body := Html_Body || '<h1>' || Subject || '</h1>' || '<br><br><br>' || Resources(Tablenr => 1) ||
                 '<br><br><br>' || Top10cpuusage(Tablenr => 2) || '<br><br><br>' || Top10longoperations(Tablenr => 3) ||
                 '<br><br><br>' || Top10idlesesions(Tablenr => 4) || '<br><br><br>' || Deadlocks(Tablenr => 5) ||
                 '<br><br><br>' || Invalidobjects(Tablenr => 6) || '<br><br><br>' || Tablespaces(Tablenr => 7) ||
                 '<br><br><br>' || Temporarytablespaces(Tablenr => 8) || '<br><br><br>' || Dbdatafiles(Tablenr => 9) ||
                 '<br><br><br>' || Unextendableobjects(Tablenr => 10) || '<br><br><br>' ||
                 Statisticsjobrun(Tablenr => 11) || '<br><br><br>' || Backuprman(Tablenr => 12) || '<br><br><br>' ||
                 Backuprmandetails(Tablenr => 13) || Disk_Usage_Table || '</body></html>';
  
    --Dbms_Output.Put_Line(Html_Body);
  
    INSERT INTO Email (Createdate, Maildata, Hostname, Sent) VALUES (SYSDATE, Html_Body, Host_Name, 0);
    COMMIT;
  
    /*    Html_Email_V2(p_To            => Crisoftadm.Array('andrei.tataru@mdlz.com', 'andrei.tataru@crisoft.ro'),
    p_Cc            => Crisoftadm.Array('andrei.tataru@mdlz.com'),
    p_Bcc           => Crisoftadm.Array('andrei.tataru@mdlz.com'),
    p_From          => Frrom,
    p_Subject       => Subject,
    p_Text          => '-------',
    p_Html          => Html_Body,
    p_Smtp_Hostname => Smtphostname,
    p_Smtp_Portnum  => Smtpportnumber);*/
  
  END Health_Check;

  PROCEDURE Disk_Usage(Disk_Usage_Table VARCHAR2, Host_Name VARCHAR2) AS
  
    Html_Body      CLOB;
    Recipient      VARCHAR2(200);
    Frrom          VARCHAR2(200);
    Subject        VARCHAR2(4000);
    Smtphostname   VARCHAR2(200);
    Smtpportnumber VARCHAR2(6);
  BEGIN
  
    Smtphostname   := 'localhost';
    Smtpportnumber := '465';
    Recipient      := 'andrei.tataru@mdlz.com';
    Frrom          := 'Crisoft_Admins@crisoft.ro';
    --frrom := 'andrei.tataru@crisoft.ro';
    Subject := 'Disk Usage Check on ' || Host_Name || ' at ' || To_Char(SYSDATE);
    Dbms_Output.Put_Line(Subject);
    Html_Body := '<!DOCTYPE html>
<html>
<head>
';
    Html_Body := Html_Body || Printstyle || '
</head>

<body>';
    Html_Body := Html_Body || '<h1>' || Subject || '</h1>' || '<br><br><br>' || Disk_Usage_Table || '</body></html>';
    --Dbms_Output.Put_Line(Html_Body);
  
    INSERT INTO Email (Createdate, Maildata, Hostname, Sent) VALUES (SYSDATE, Html_Body, Host_Name, 0);
    COMMIT;
  
    /*    Html_Email_V2(p_To            => Crisoftadm.Array('andrei.tataru@mdlz.com', 'andrei.tataru@crisoft.ro'),
    p_Cc            => Crisoftadm.Array('andrei.tataru@mdlz.com'),
    p_Bcc           => Crisoftadm.Array('andrei.tataru@mdlz.com'),
    p_From          => Frrom,
    p_Subject       => Subject,
    p_Text          => '-------',
    p_Html          => Html_Body,
    p_Smtp_Hostname => Smtphostname,
    p_Smtp_Portnum  => Smtpportnumber);*/
  END Disk_Usage;

  FUNCTION Cssreset RETURN VARCHAR2 IS
  BEGIN
    RETURN 'body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td {
margin:0;
padding:0;
}
html,body {
margin:0;
padding:0;
}
table {
border-collapse:collapse;
border-spacing:0;
}
fieldset,img {
border:0;
}
input{
border:1px solid #b0b0b0;
padding:3px 5px 4px;
color:#979797;
width:190px;
}
address,caption,cite,code,dfn,th,var {
font-style:normal;
font-weight:normal;
}
ol,ul {
list-style:none;
}
caption,th {
text-align:left;
}
h1,h2,h3,h4,h5,h6 {
font-size:100%;
font-weight:normal;
}
q:before,q:after {
content:'''';
}
abbr,acronym { border:0;
}';
  END Cssreset;
  FUNCTION Printstyle RETURN VARCHAR2 AS
  BEGIN
    RETURN '<style>
' ||
    --cssReset ||
     '
table {
font-family:"Trebuchet MS", Arial, Helvetica, sans-serif;
width:100%;
heigth:100%;
border-collapse:collapse;
}

td {
font-size:1em;
text-align:center;
border:1px solid #0041C2;
padding:3px 7px 2px 7px;
}

th {
font-size:1em;
text-align:center;
border:1px solid #0041C2;
padding:3px 7px 2px 7px;
font-size:1.1em;
padding-top:5px;
padding-bottom:4px;
background-color:#0041C2;
color:#ffffff;
}


tr.alt td
{
color:#000000;
background-color:#659EC7;
}

tr.alterr td
{
color:#FFFFFF;
background-color:#F70D1A;
}

caption {
color:#ffffff;
border:1px solid #F70A1A;
background-color:#7D0552;
caption-side:top;
}

h1 {
text-align:center;
}

</style> ';
  END Printstyle;
  FUNCTION Resources(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '
<table>
<caption>Table ' || Tablenr || ': Resource usage</caption>
<tr>
<th>Resource name</th>
<th>Curent Utilization</th>
<th>Initial Allocation</th>
<th>Max Utilization</th>
<th>Limit value</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT *
                FROM V$resource_Limit
               WHERE Resource_Name IN ('processes', 'sessions', 'enqueue_locks', 'max_rollback_segments'))
    LOOP
      IF i.Limit_Value - i.Current_Utilization < 15
      THEN
        Res := Res || '<tr class="alterr">' || Chr(13) || Chr(10);
      ELSE
        IF MOD(Cnt, 2) = 0
        THEN
          Res := Res || '<tr>' || Chr(13) || Chr(10);
        ELSE
          Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
        END IF;
      END IF;
      Res := Res || '<td>' || i.Resource_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Current_Utilization || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Initial_Allocation || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Max_Utilization || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Limit_Value || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="4">' || 'No Resources found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Resources;
  FUNCTION Tablespaces(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '
<table>
<caption>Table ' || Tablenr || ': Tablespace utilization</caption>
<tr>
<th>Tablespace Name</th>
<th>Used (MB)</th>
<th>Free (MB)</th>
<th>Total (MB)</th>
<th>Free Percentage %</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT a.Tablespace_Name,
                     To_Char(SUM(a.Bytes) / 1024 / 1024, '999,999.99') Used,
                     To_Char(SUM(a.Maxbytes - a.Bytes) / 1024 / 1024, '999,999.99') Free,
                     To_Char(SUM(a.Maxbytes) / 1024 / 1024, '999,999.99') Total,
                     To_Char(SUM(a.Maxbytes - a.Bytes) / SUM(a.Maxbytes) * 100, '999') Per_Free
                FROM Dba_Data_Files a
               GROUP BY a.Tablespace_Name)
    LOOP
      IF i.Per_Free < 15
      THEN
        Res := Res || '<tr class="alterr">' || Chr(13) || Chr(10);
      ELSE
        IF MOD(Cnt, 2) = 0
        THEN
          Res := Res || '<tr>' || Chr(13) || Chr(10);
        ELSE
          Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
        END IF;
      END IF;
      Res := Res || '<td>' || i.Tablespace_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Used || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Free || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Total || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Per_Free || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="4">' || 'No Tablespaces found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Tablespaces;
  FUNCTION Dbdatafiles(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': DB Data files</caption>
<tr>
<th>File Name</th>
<th>Tablespace Name</th>
<th>Size (MB)</th>
<th>Blocks</th>
<th>Status</th>
<th>Autoextensible</th>
<th>Online Status</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT File_Name, Tablespace_Name, Bytes / 1024 / 1024 Mb, Blocks, Status, Autoextensible, Online_Status
                FROM Dba_Data_Files)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.File_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Tablespace_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Mb || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Blocks || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Status || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Autoextensible || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Online_Status || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="7">' || 'No data files found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Dbdatafiles;
  FUNCTION Invalidobjects(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(32000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': Invalid Objects</caption>
<tr>
<th>Owner</th>
<th>Object Name</th>
<th>Object Type</th>
<th>Status</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Owner, Object_Name, Object_Type, Status
                FROM Dba_Objects
               WHERE Status = 'INVALID'
               ORDER BY Owner, Object_Type, Object_Name)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.Owner || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Object_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Object_Type || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Status || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="4">' || 'No invalid objects found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Invalidobjects;
  FUNCTION Deadlocks(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': DeadLocks</caption>
<tr>
<th>Sid</th>
<th>Blocker</th>
<th>Waiter</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Sid, Decode(BLOCK, 0, 'NO', 'YES') Blocker, Decode(Request, 0, 'NO', 'YES') Waiter
                FROM V$lock
               WHERE Request > 0
                  OR BLOCK > 0
               ORDER BY BLOCK DESC)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.Sid || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Blocker || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Waiter || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="4">' || 'No deadlocks found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Deadlocks;
  FUNCTION Unextendableobjects(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': Unextendable Objects</caption>
<tr>
<th>Owner</th>
<th>Segment Type</th>
<th>Segment Name</th>
<th>Tablespace Name</th>
<th>Request</th>
<th>Max Free</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT s.Owner,
                     s.Segment_Type,
                     s.Segment_Name,
                     s.Tablespace_Name,
                     s.Next_Extent / 1024 / 1024 Req,
                     Maxtspace.Max / 1024 / 1024 Maxfree
                FROM Dba_Segments s,
                     (SELECT Tablespace_Name, MAX(Fsu.Bytes) MAX FROM Dba_Free_Space Fsu GROUP BY Tablespace_Name) Maxtspace
               WHERE s.Tablespace_Name = Maxtspace.Tablespace_Name
                 AND Segment_Type IN ('TABLE', 'INDEX', 'CLUSTER', 'TABLE PARTITION', 'INDEX PARTITION')
                 AND Next_Extent > Maxtspace.Max)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.Owner || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Segment_Type || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Segment_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Tablespace_Name || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Req || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Maxfree || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="6">' || 'No unextendable objects found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Unextendableobjects;
  FUNCTION Top10cpuusage(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': TOP 10 programs by cpu time</caption>
<tr>
<th>Rank</th>
<th>Sid</th>
<th>Program</th>
<th>CPU time (min)</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT v.Sid, Program, To_Char(v.Value / (100 * 60), '999.999') Cpumins
                FROM V$statname s, V$sesstat v, V$session Sess
               WHERE s.Name = 'CPU used by this session'
                 AND Sess.Sid = v.Sid
                 AND v.Statistic# = s.Statistic#
                 AND v.Value > 0
                 AND Rownum <= 10
                 AND Program NOT LIKE '%ORACLE%'
               ORDER BY v.Value DESC)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || To_Char(Cnt + 1, '99') || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Sid || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Program || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Cpumins || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="4">' || 'No programs found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Top10cpuusage;
  FUNCTION Top10longoperations(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': TOP 10 long operations</caption>
<tr>
<th>Rank</th>
<th>Sid</th>
<th>User Name</th>
<th>Operation Name</th>
<th>Progress</th>
<th>Total Work</th>
<th>Units</th>
<th>Start Time</th>
<th>Job Duration</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Sid,
                     Username,
                     Opname,
                     Decode(Totalwork, 0, 0, NULL, 0, Sofar * 100 / Totalwork) Progress,
                     Totalwork,
                     Units,
                     Start_Time,
                     To_Char(Elapsed_Seconds / 60, '999.999') AS Job_Dur_Min
                FROM V$session_Longops
               WHERE Elapsed_Seconds > 0
                 AND Rownum < 11
               ORDER BY Elapsed_Seconds DESC, Sid, Start_Time)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || To_Char(Cnt + 1, '99') || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Sid || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Username || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Opname || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Progress || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Totalwork || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Units || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Start_Time || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Job_Dur_Min || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="9">' || 'No long operations found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Top10longoperations;
  FUNCTION Temporarytablespaces(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': Temporary Tablespaces</caption>
<tr>
<th>Sid serial</th>
<th>User Name</th>
<th>Tablespace</th>
<th>Size</th>
<th>Program</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT b.Tablespace,
                     Round(((b.Blocks * p.Value) / 1024 / 1024), 2) || 'M' "SIZE",
                     a.Sid || ',' || a.Serial# Sid_Serial,
                     a.Username,
                     a.Program
                FROM Sys.v_$session a, Sys.v_$sort_Usage b, Sys.v_$parameter p
               WHERE p.Name = 'db_block_size'
                 AND a.Saddr = b.Session_Addr
               ORDER BY b.Tablespace, b.Blocks)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.Sid_Serial || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Username || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Tablespace || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i."SIZE" || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Program || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="5">' || 'No temporary tablesapaces found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Temporarytablespaces;
  FUNCTION Top10idlesesions(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': TOP 10 IDLE Sesions</caption>
<tr>
<th>Rank</th>
<th>Sid</th>
<th>Username</th>
<th>Status</th>
<th>Logon Time</th>
<th>Program</th>
<th>Idle</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Sid,
                     Username,
                     Status,
                     To_Char(Logon_Time, 'dd-mm-yy hh:mi:ss') Logon_Time,
                     Floor(Last_Call_Et / 3600) || ' hours ' || Floor(MOD(Last_Call_Et, 3600) / 60) || ' mins ' ||
                     MOD(MOD(Last_Call_Et, 3600), 60) || ' secs' Idle,
                     Program
                FROM V$session
               WHERE TYPE = 'USER'
                 AND Rownum <= 10
               ORDER BY Idle DESC)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || To_Char(Cnt + 1, '99') || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Sid || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Username || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Status || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Logon_Time || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Program || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Idle || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="7">' || 'No idle sesions found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Top10idlesesions;
  FUNCTION Statisticsjobrun(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': Statistics job Status</caption>
<tr>
<th>Job</th>
<th>Broken</th>
<th>Failures</th>
<th>What</th>
<th>Last Date</th>
<th>Last Sec</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Job, Broken, Failures, What, Last_Date, Last_Sec
                FROM Dba_Jobs
               WHERE What LIKE '%DBMS_STATS.GATHER_SCHEMA_STATS%')
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.Job || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Broken || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Failures || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.What || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Last_Date || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Last_Sec || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="6">' || 'No Statistics job found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Statisticsjobrun;
  FUNCTION Backuprman(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': RMAN BackUP job Status</caption>
<tr>
<th>Session Key</th>
<th>Input Type</th>
<th>Status</th>
<th>Start Time</th>
<th>End Time</th>
<th>dur_min</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Session_Key,
                     Input_Type,
                     Status,
                     To_Char(Start_Time, 'mm/dd/yy hh24:mi') Start_Time,
                     To_Char(End_Time, 'mm/dd/yy hh24:mi') End_Time,
                     To_Char(Elapsed_Seconds / 60, '99.90') Dur_Min
                FROM V$rman_Backup_Job_Details
               ORDER BY Session_Key)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i.Session_Key || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Input_Type || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Status || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Start_Time || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.End_Time || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Dur_Min || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="6">' || 'No rman backup  job found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Backuprman;
  FUNCTION Backuprmandetails(Tablenr NUMBER) RETURN VARCHAR2 AS
    Cnt INTEGER;
    Res VARCHAR2(4000);
  BEGIN
    Res := '<table>
<caption>Table ' || Tablenr || ': RMAN BackUP job Status</caption>
<tr>
<th>Date</th>
<th>Backup Type</th>
<th>Size</th>
</tr>
';
    Cnt := 0;
    FOR i IN (SELECT Ctime "Date",
                     Decode(Backup_Type, 'L', 'Archive Log', 'D', 'Full', 'Incremental') Backup_Type,
                     Bsize "Size MB"
                FROM (SELECT Trunc(Bp.Completion_Time) Ctime, Backup_Type, Round(SUM(Bp.Bytes / 1024 / 1024), 2) Bsize
                        FROM V$backup_Set Bs, V$backup_Piece Bp
                       WHERE Bs.Set_Stamp = Bp.Set_Stamp
                         AND Bs.Set_Count = Bp.Set_Count
                         AND Bp.Status = 'A'
                       GROUP BY Trunc(Bp.Completion_Time), Backup_Type)
               ORDER BY 1, 2)
    LOOP
      IF MOD(Cnt, 2) = 0
      THEN
        Res := Res || '<tr>' || Chr(13) || Chr(10);
      ELSE
        Res := Res || '<tr class="alt">' || Chr(13) || Chr(10);
      END IF;
      Res := Res || '<td>' || i."Date" || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i.Backup_Type || '</td>' || Chr(13) || Chr(10);
      Res := Res || '<td>' || i."Size MB" || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
      Cnt := Cnt + 1;
    END LOOP;
    IF Cnt = 0
    THEN
      Res := Res || '<td colspan="3">' || 'No rman backup  job details found' || '</td>' || Chr(13) || Chr(10);
      Res := Res || '</tr>' || Chr(13) || Chr(10);
    END IF;
    Res := Res || '</table>' || Chr(13) || Chr(10);
    RETURN Res;
  END Backuprmandetails;

  PROCEDURE Html_Email(p_To            IN VARCHAR2,
                       p_From          IN VARCHAR2,
                       p_Subject       IN VARCHAR2,
                       p_Text          IN VARCHAR2,
                       p_Html          IN VARCHAR2,
                       p_Smtp_Hostname IN VARCHAR2,
                       p_Smtp_Portnum  IN VARCHAR2) IS
    l_Boundary   VARCHAR2(255) DEFAULT 'a1b2c3d4e3f2g1';
    l_Connection Utl_Smtp.Connection;
    l_Body_Html  CLOB := Empty_Clob; --This LOB will be the email message
    l_Offset     NUMBER;
    l_Ammount    NUMBER;
    l_Temp       VARCHAR2(32767) DEFAULT NULL;
  BEGIN
    l_Connection := Utl_Smtp.Open_Connection(p_Smtp_Hostname, p_Smtp_Portnum);
    Utl_Smtp.Helo(l_Connection, p_Smtp_Hostname);
    Utl_Smtp.Command(l_Connection, 'AUTH LOGIN');
    Utl_Smtp.Command(l_Connection,
                     Utl_Raw.Cast_To_Varchar2(Utl_Encode.Base64_Encode(Utl_Raw.Cast_To_Raw('andrei.tataru@crisoft.ro'))));
    Utl_Smtp.Command(l_Connection,
                     Utl_Raw.Cast_To_Varchar2(Utl_Encode.Base64_Encode(Utl_Raw.Cast_To_Raw('S_5230_Star'))));
    Utl_Smtp.Mail(l_Connection, p_From);
    Utl_Smtp.Rcpt(l_Connection, p_To);
    -------- to add to ,bcc, cc-------
    ----------------------------------
    l_Temp := l_Temp || 'MIME-Version: 1.0' || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'To: ' || p_To || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'From: ' || p_From || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'Subject: ' || p_Subject || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'Reply-To: ' || p_From || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'Content-Type: multipart/alternative; boundary=' || Chr(34) || l_Boundary || Chr(34) || Chr(13) ||
              Chr(10);
    ----------------------------------------------------
    -- Write the headers
    Dbms_Lob.Createtemporary(l_Body_Html, FALSE, 10);
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), 1, l_Temp);
    ----------------------------------------------------
    -- Write the text boundary
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    l_Temp   := '--' || l_Boundary || Chr(13) || Chr(10);
    l_Temp   := l_Temp || 'content-type: text/plain; charset=us-ascii' || Chr(13) || Chr(10) || Chr(13) || Chr(10);
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), l_Offset, l_Temp);
    ----------------------------------------------------
    -- Write the plain text portion of the email
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(p_Text), l_Offset, p_Text);
    ----------------------------------------------------
    -- Write the HTML boundary
    l_Temp   := Chr(13) || Chr(10) || Chr(13) || Chr(10) || '--' || l_Boundary || Chr(13) || Chr(10);
    l_Temp   := l_Temp || 'content-type: text/html;' || Chr(13) || Chr(10) || Chr(13) || Chr(10);
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), l_Offset, l_Temp);
    ----------------------------------------------------
    -- Write the HTML portion of the message
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(p_Html), l_Offset, p_Html);
    ----------------------------------------------------
    -- Write the final html boundary
    l_Temp   := Chr(13) || Chr(10) || '--' || l_Boundary || '--' || Chr(13);
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), l_Offset, l_Temp);
    ----------------------------------------------------
    -- Send the email in 1900 byte chunks to UTL_SMTP
    l_Offset  := 1;
    l_Ammount := 1900;
    Utl_Smtp.Open_Data(l_Connection);
    WHILE l_Offset < Dbms_Lob.Getlength(l_Body_Html)
    LOOP
      Utl_Smtp.Write_Data(l_Connection, Dbms_Lob.Substr(l_Body_Html, l_Ammount, l_Offset));
      l_Offset  := l_Offset + l_Ammount;
      l_Ammount := Least(1900, Dbms_Lob.Getlength(l_Body_Html) - l_Ammount);
    END LOOP;
    Utl_Smtp.Close_Data(l_Connection);
    Utl_Smtp.Quit(l_Connection);
    Dbms_Lob.Freetemporary(l_Body_Html);
  END;
  /*FUNCTION createTableHTML(
          t_id NUMBER)
      RETURN VARCHAR2
  AS
      c1 healt_checks%ROWTYPE;
  BEGIN
      SELECT * INTO c1 FROM healt_checks WHERE "ID" = t_id;
      RETURN NULL;
  END createTableHTML;*/

  FUNCTION Address_Email(p_String IN VARCHAR2, p_Recipients IN ARRAY, l_Connection Utl_Smtp.Connection) RETURN VARCHAR2 IS
    l_Recipients LONG;
  
    t_Connection Utl_Smtp.Connection;
  BEGIN
  
    t_Connection := l_Connection;
    FOR i IN 1 .. p_Recipients.Count
    LOOP
      Utl_Smtp.Rcpt(t_Connection, p_Recipients(i));
      IF (l_Recipients IS NULL)
      THEN
        l_Recipients := p_String || p_Recipients(i);
      ELSE
        l_Recipients := l_Recipients || ', ' || p_Recipients(i);
      END IF;
    END LOOP;
    RETURN l_Recipients;
  END;

  PROCEDURE Html_Email_V2(p_To            IN ARRAY DEFAULT ARRAY(),
                          p_Cc            IN ARRAY DEFAULT ARRAY(),
                          p_Bcc           IN ARRAY DEFAULT ARRAY(),
                          p_From          IN VARCHAR2,
                          p_Subject       IN VARCHAR2,
                          p_Text          IN VARCHAR2,
                          p_Html          IN VARCHAR2,
                          p_Smtp_Hostname IN VARCHAR2,
                          p_Smtp_Portnum  IN VARCHAR2) AS
  
    l_To_List  LONG;
    l_Cc_List  LONG;
    l_Bcc_List LONG;
  
    l_Boundary   VARCHAR2(255) DEFAULT 'a1b2c3d4e3f2g1';
    l_Connection Utl_Smtp.Connection;
    l_Body_Html  CLOB := Empty_Clob; --This LOB will be the email message
    l_Offset     NUMBER;
    l_Ammount    NUMBER;
    l_Temp       VARCHAR2(32767) DEFAULT NULL;
  BEGIN
    l_Connection := Utl_Smtp.Open_Connection(p_Smtp_Hostname, p_Smtp_Portnum);
    Utl_Smtp.Helo(l_Connection, p_Smtp_Hostname);
    Utl_Smtp.Command(l_Connection, 'AUTH LOGIN');
    Utl_Smtp.Command(l_Connection,
                     Utl_Raw.Cast_To_Varchar2(Utl_Encode.Base64_Encode(Utl_Raw.Cast_To_Raw('andrei.tataru@crisoft.ro'))));
    Utl_Smtp.Command(l_Connection,
                     Utl_Raw.Cast_To_Varchar2(Utl_Encode.Base64_Encode(Utl_Raw.Cast_To_Raw('S_5230_Star'))));
    Utl_Smtp.Mail(l_Connection, p_From);
  
    l_To_List  := Address_Email('To: ', p_To, l_Connection);
    l_Cc_List  := Address_Email('Cc: ', p_Cc, l_Connection);
    l_Bcc_List := Address_Email('Bcc: ', p_Bcc, l_Connection);
    --utl_smtp.rcpt(l_connection, p_to) ;
  
    --utl_smtp.write_data( l_connection, l_to_list || chr(13) || chr(10) );
    --utl_smtp.write_data( l_connection, l_cc_list || chr(13) || chr(10) );
    --utl_smtp.write_data( l_connection, l_bcc_list || chr(13) || chr(10) );
    -------- to add to ,bcc, cc-------
    ----------------------------------
    l_Temp := l_Temp || 'MIME-Version: 1.0' || Chr(13) || Chr(10);
    --l_temp := l_temp || 'To: ' || p_to || chr(13) || chr(10) ;
    l_Temp := l_Temp || l_To_List || Chr(13) || Chr(10);
    l_Temp := l_Temp || l_Cc_List || Chr(13) || Chr(10);
    l_Temp := l_Temp || l_Bcc_List || Chr(13) || Chr(10);
  
    l_Temp := l_Temp || 'From: ' || p_From || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'Subject: ' || p_Subject || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'Reply-To: ' || p_From || Chr(13) || Chr(10);
    l_Temp := l_Temp || 'Content-Type: multipart/alternative; boundary=' || Chr(34) || l_Boundary || Chr(34) || Chr(13) ||
              Chr(10);
    ----------------------------------------------------
    -- Write the headers
    Dbms_Lob.Createtemporary(l_Body_Html, FALSE, 10);
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), 1, l_Temp);
    ----------------------------------------------------
    -- Write the text boundary
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    l_Temp   := '--' || l_Boundary || Chr(13) || Chr(10);
    l_Temp   := l_Temp || 'content-type: text/plain; charset=us-ascii' || Chr(13) || Chr(10) || Chr(13) || Chr(10);
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), l_Offset, l_Temp);
    ----------------------------------------------------
    -- Write the plain text portion of the email
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(p_Text), l_Offset, p_Text);
    ----------------------------------------------------
    -- Write the HTML boundary
    l_Temp   := Chr(13) || Chr(10) || Chr(13) || Chr(10) || '--' || l_Boundary || Chr(13) || Chr(10);
    l_Temp   := l_Temp || 'content-type: text/html;' || Chr(13) || Chr(10) || Chr(13) || Chr(10);
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), l_Offset, l_Temp);
    ----------------------------------------------------
    -- Write the HTML portion of the message
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(p_Html), l_Offset, p_Html);
    ----------------------------------------------------
    -- Write the final html boundary
    l_Temp   := Chr(13) || Chr(10) || '--' || l_Boundary || '--' || Chr(13);
    l_Offset := Dbms_Lob.Getlength(l_Body_Html) + 1;
    Dbms_Lob.Write(l_Body_Html, Length(l_Temp), l_Offset, l_Temp);
    ----------------------------------------------------
    -- Send the email in 1900 byte chunks to UTL_SMTP
    l_Offset  := 1;
    l_Ammount := 1900;
    Utl_Smtp.Open_Data(l_Connection);
    WHILE l_Offset < Dbms_Lob.Getlength(l_Body_Html)
    LOOP
      Utl_Smtp.Write_Data(l_Connection, Dbms_Lob.Substr(l_Body_Html, l_Ammount, l_Offset));
      l_Offset  := l_Offset + l_Ammount;
      l_Ammount := Least(1900, Dbms_Lob.Getlength(l_Body_Html) - l_Ammount);
    END LOOP;
    Utl_Smtp.Close_Data(l_Connection);
    Utl_Smtp.Quit(l_Connection);
    Dbms_Lob.Freetemporary(l_Body_Html);
  END Html_Email_V2;

BEGIN
  NULL;
  --EXECUTE IMMEDIATE 'DROP TABLE IF EXISTS email_message';
--EXECUTE IMMEDIATE 'CREATE TABLE email_message (job_id NUMBER, recipient VARCHAR2(200), sender VARCHAR2(200),
-- message CLOB, sent varchar2(1))';

--CREATE TABLE email_message (job_id NUMBER, to_recipients VARCHAR2(2000), cc_recipients VARCHAR2(2000), bcc_recipients VARCHAR2(2000), sender VARCHAR2(200),message CLOB, sent varchar2(1));
--CREATE TABLE HEALT_CHECKS (ID NUMBER, DESCR VARCHAR2(200), SQL VARCHAR2(4000));

END Crisoftadm;
